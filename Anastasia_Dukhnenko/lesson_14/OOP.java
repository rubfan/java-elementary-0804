public class OOP {
    public static void main(String[] args) {
        System.out.println("1. Назовите принципы ООП и расскажите о каждом.\n" +
                "- наследование\n" +
                "- полиморфизм\n" +
                "- абстракция\n" +
                "- инкапсуляция\n" +
                "Наследование – это механизм, который позволяет одному объекту наследовать поведение и атрибуты другого объекта. С помощью наследования можно создать новый класс объектов, указав\n" +
                "лишь отличия этого класса от предыдущего.\n" +
                "Полиморфизм - это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта.\n" +
                "Абстракция – это процесс скрытия деталей реализации от пользователя, предоставляя ему только функционал. Пользователь будет владеть информацией о том, что объект делает, а не как он это делает.\n" +
                "Инкапсуляция - механизм обёртывания данных и кода, работающего с методами, в одно целое. В инкапсуляции переменные класса будут скрыты от других классов и доступ к ним может быть получен только с помощью метода их текущего класса.\n" +
                "\n" +
                "2. Дайте определение понятию “класс”.\n" +
                "Это шаблон программы, по которому создаётся какой-то объект.\n" +
                "\n" +
                "3. Что такое поле/атрибут класса?\n" +
                "Это характеристика объекта.\n" +
                "\n" +
                "4. Как правильно организовать доступ к полям класса?\n" +
                "Через модификатор доступа private.\n" +
                "\n" +
                "5. Дайте определение понятию “конструктор”.\n" +
                "Это специальный метод класса, который выполняет всю необходимую работу по \n" +
                "созданию объекта. Назначение конструктора заключается в настройке всех\n" +
                "переменных и вызове методов, которые должны быть выполнены для корректного функционирования объекта.\n" +
                "\n" +
                "6. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?\n" +
                "Конструктор по-умолчанию – это конструктор, который Java создаст, даже если его не написали. Этот конструктор пустой и не делает ничего, кроме вызова конструктора суперкласса.\n" +
                "Конструктор копирования – клонирует объекты. В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.\n" +
                "Конструктор с параметрами - также как и метод принимает на вход параметры.\n" +
                "\n" +
                "7. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.\n" +
                "public – видимый для всех\n" +
                "private – видимый только для класса\n" +
                "protected – видимый для пакета и подклассов\n" +
                "default – видимый в пакете, стоит по умолчанию\n" +
                "\n" +
                "8. Расскажите об особенностях класса с единственным закрытым (private) конструктором.\n" +
                "От такого класса нельзя наследоваться.\n" +
                "\n" +
                "9. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?\n" +
                "super используется для обращения с отцовским классом\n" +
                "this – для текущего\n" +
                "\n" +
                "10. Дайте определение понятию “метод”.\n" +
                "Метод – это задача (функция), выполняемая объектом.\n" +
                "\n" +
                "11. Что такое сигнатура метода?\n" +
                "Это код, который описывает метод. Включает в себя название метода и типы параметров.\n" +
                "Имеет вид:\n" +
                "модификатор доступа, тип возвращаемого значения, имя метода(список параметров) {\n" +
                "    // тело метода\n" +
                "}\n" +
                "\n" +
                "12. Какие методы называются перегруженными?\n" +
                "Это использование методов с одинаковыми именами, но разной сигнатурой/набором параметров.\n" +
                "\n" +
                "13. Могут ли нестатические методы перегрузить статические?\n" +
                "Да, программа будет считать их за два разных метода.\n" +
                "14. Расскажите про переопределение методов.\n" +
                "Это метод, который совпадает по сигнатуре с методом из родительского класса.\n" +
                "\n" +
                "15. Может ли метод принимать разное количество параметров (аргументы переменной длины)?\n" +
                "Да. Для этого нужно написать method(type … val).\n" +
                "\n" +
                "16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?\n" +
                "Нельзя. \n" +
                "\n" +
                "17. Как получить доступ к переопределенным методам родительского класса?\n" +
                "С помочью ключевого слова super. \n" +
                "super.method();\n" +
                "\n" +
                "18. Какие преобразования называются нисходящими и восходящими?\n" +
                "От потомка к родителю – восходящими, и наоборот – нисходящими.\n" +
                "\n" +
                "19. Чем отличается переопределение от перегрузки?\n" +
                "При перегрузке мы используем одно имя, но с разными входными параметрами.\n" +
                "При переопределении мы переписываем уже существующий метод.\n" +
                "При перегрузке мы создаём метод, при переопределении используем существующий.\n" +
                "\n" +
                "20. Где можно инициализировать статические/нестатические поля?\n" +
                "Статические поля инициализируются при объявлении, в статических и динамических блоках.\n" +
                "Нестатические – при объявлении, в конструкторе и динамических блоках.\n" +
                "21. Зачем нужен оператор instanceof?\n" +
                "Если объект является экземпляром класса или его потомком, то он возвращает true.\n" +
                "\n" +
                "22. Зачем нужны и какие бывают блоки инициализации?\n" +
                "Существуют статические и динамические блоки инициализации.\n" +
                "Статические – для статических переменных, динамические – для нестатических.\n" +
                "Блоки инициализации делают код более читабельным, в них можно вызывать любые методы.\n" +
                "Основная задача – инициализация переменных внутри класса.\n" +
                "\n" +
                "23. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?\n" +
                "Сначала вызываются статические блоки от предка до наследника. Потом динамический блок и конструктор в той же последовательности.\n" +
                "\n" +
                "24. Где и для чего используется модификатор abstract?\n" +
                "Этот модификатор используется для класса, в котором нельзя создавать объекты. Наследники такого класса могут быть не абстрактными. Если хотя бы один метод в классе абстрактный – то и весь класс абстрактный.\n" +
                "\n" +
                "25. Можно ли объявить метод абстрактным и статическим одновременно?\n" +
                "Нет. Если метод статический, то он будет доступен по имени класса. Если абстрактный, то наоборот – он будет реализован не в этом классе, а другом.\n" +
                "\n" +
                "26. Что означает ключевое слово static?\n" +
                "Это ключевое слово ставится возле метода или объекта, который принадлежит классу. \n" +
                "Если метод статический, то он должен иметь доступ только к статик переменным, вызывать статик методы и не могут иметь отношение к this и super.\n" +
                "\n" +
                "27. К каким конструкциям Java применим модификатор static?\n" +
                "Методы, поля, внутренний класс, импортируемые классы.\n" +
                "\n" +
                "28. Можно ли перегрузить static метод?\n" +
                "Да.\n" +
                "\n" +
                "29. Что такое статический класс, какие особенности его использования?\n" +
                "Это класс, который находится внутри основного класса, может обращаться только к статическим полям и методам основного класса.\n" +
                "\n" +
                "30. Какие особенности инициализации final static переменных?\n" +
                "Их можно инициализировать только в стати блоке или при объявлении.\n" +
                "\n" +
                "31. Как влияет модификатор static на класс/метод/поле?\n" +
                "Это говорит о том, что статик метод или поле принадлежат классу, а не объекту. \n" +
                "Внутри статик метода можно вызывать только статик методы.\n" +
                "Статик класс может находиться только внутри основного класса, может обращаться только к статическим полям и методам основного класса.\n" +
                "\n" +
                "\n" +
                "32. О чем говорит ключевое слово final?\n" +
                "Поле – не может изменить своё значение после инициализации.\n" +
                "Метод – не может быть переопределен.\n" +
                "Класс – не может иметь наследников.\n" +
                "\n" +
                "33. Дайте определение понятию “интерфейс”.\n" +
                "Это «контракт», класс который имплементирует его должен реализовать все «условия».\n" +
                "В интерфейсе создаются методы, аргументы и типы возвращаемых значений, но не их тела. \n" +
                "\n" +
                "34. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?\n" +
                "Поля - static final\n" +
                "Методы - public\n" +
                "\n" +
                "35. Почему нельзя объявить метод интерфейса с модификатором final или static?\n" +
                "Потому что он создаётся для того, чтобы его реализовали где-то ещё.\n" +
                "\n" +
                "36. Какие типы классов бывают в java (вложенные… и.т.д.)\n" +
                "Обычные классы, перечисления, интерфейсы, локальные классы, анонимные классы, вложенные статические и вложенные нестатические классы.\n" +
                "\n" +
                "37. Какие особенности создания вложенных классов: простых и статических.\n" +
                "Простые:\n" +
                "- внутри не может быть статических переменных;\n" +
                "- они существуют только у объектов;\n" +
                "- имеют доступ к приватным полям внешнего класса;\n" +
                "- можно получить ссылку на экземпляр внешнего класса.\n" +
                "Статические:\n" +
                "- могут содержать только статические методы;\n" +
                "- можно обращаться к внутренним статик полям и методам основного класса.\n" +
                "\n" +
                "38. Какие классы называются анонимными?\n" +
                "Это локальные классы без имени и их создание происходит в момент инициализации объекта. \n" +
                "\n" +
                "39. Как связан любой пользовательский класс с классом Object?\n" +
                "Все классы являются наследниками этого суперкласса. \n" +
                "\n" +
                "40. Расскажите про каждый из методов класса Object.\n" +
                "public boolean equals(Object obj) – сравнение объектов\n" +
                "public String toString() – возвращает строковое значение объекта\n" +
                "public final native Class getClass() – возвращает в рантайме класс данного объекта\n" +
                "public native int hashCode() – возвращает хеш-код\n" +
                "protected native Object clone() throws CloneNotSupportedException – клонирование объекта\n" +
                "public final native void notify() – просыпается один поток, который ждет объект\n" +
                "public final native void notifyAll() – просыпаются все потоки, которые ждут объект\n" +
                "public final native void wait(long timeout) throws InterruptedException – поток переходит в режим ожидания в течение указанного времени\n" +
                "public final void wait() throws InterruptedException – приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта\n" +
                "public final void wait(long timeout, int nanos) throws InterruptedException – приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени\n" +
                "protected void finalize() throws Throwable – вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет\n" +
                "\n" +
                "41. Чем отличается абстрактный класс от интерфейса, в каких случаях что вы будете использовать?\n" +
                "Интерфейс – это класс, в котором не могут быть определены тела у методов и нет свойств. \n" +
                "Абстрактный класс – это класс, у которого хотя бы один абстрактный метод.\n" +
                "Наследовать класс может только однажды, а вот имплементировать – сколько угодно. \n" +
                "С абстрактными классами теряется индивидуальность класса, с интерфейсами  - расширяется функционал.\n" +
                "\n" +
                "42. Можно ли получить доступ к private переменным класса и если да, то каким образом?\n" +
                "Да.\n" +
                "Вызов из другого класса:\n" +
                "OurClass ourClass = new OurClass();\n" +
                "Field field = OurClass.class. getDeclaredField(\"name\");\n" +
                "Field field2 = OurClass.class. getDeclaredField(\"age\");\n" +
                "field.setAccessible(true);\n" +
                "field2.setAccessible(true);\n" +
                "String fieldValue = (String) reflectField.get(ourClass);\n" +
                "Integer fieldValue2 = (Integer) reflectField2.get(ourClass);\n" +
                "\n" +
                "\n" +
                "43. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость? А если protected? А сузить видимость?\n" +
                "Расширить можно, а сузить нельзя.\n" +
                "\n" +
                "44. Имеет ли смысл объявлять метод private final?\n" +
                "Нет.\n" +
                "\n" +
                "45. Какие особенности инициализации final переменных?\n" +
                "Такую переменную невозможно изменить после инициализации.\n" +
                "\n" +
                "46. Что будет, если единственный конструктор класса объявлен как final?\n" +
                "Ошибка.\n");
    }
}
