public class Text {
    final static String TEXT = "1. Назовите принципы ООП и расскажите о каждом.\n" +
            "    Абстракция:     перенос свойств реальных объектов в программу и обобщение признаков\n" +
            "    Наследование:   использование уже существующих классов для создания новых\n" +
            "    Инкапсуляция:   возможность определять, к каким свойствам и методам объекта, ограничить доступ извне\n" +
            "    Полиморфизм:    возможность для методов с одинаковой сигнатурой вызывать разные реализации\n" +
            "                    у классов связанных наследованием или интерфейсом.\n" +
            "2. Дайте определение понятию “класс”.\n" +
            "    Это шаблон для создания объекта\n" +
            "3. Что такое поле/атрибут класса?\n" +
            "    Это свойства объекта\n" +
            "4. Как правильно организовать доступ к полям класса?\n" +
            "    Через использование модификаторов доступа или методы.\n" +
            "5. Дайте определение понятию “конструктор”.\n" +
            "    Специальный метод для задания параметров объекта при его создании\n" +
            "6. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?\n" +
            "    По-умолчанию: конструктор без параметров\n" +
            "    Копирования: принимает как параметр объект класса\n" +
            "    С параметрами: принимает на вход данные для инициализации полей класса\n" +
            "7. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.\n" +
            "    Private:    доступно только внутри класса\n" +
            "    Default:    доступно только внутри пакета\n" +
            "    Protected:  доступно только внутри пакета или наследникам в другом пакете\n" +
            "    Public:     доступно в любом месте программы\n" +
            "8. Расскажите об особенностях класса с единственным закрытым (private) конструктором.\n" +
            "    Объект класса невозможно создать за пределами класса и унаследоваться от него\n" +
            "9. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?\n" +
            "    this:   это указание на использование аттрибутов текущего класса\n" +
            "    super:  это указание на использование аттрибутов родительского класса\n" +
            "    Используется для кострукторов и методов внутри классов\n" +
            "10. Дайте определение понятию “метод”.\n" +
            "    Вызываемый по имени фрагмент кода, решающий какую-нибудь задачу\n" +
            "11. Что такое сигнатура метода?\n" +
            "    Это имя метода и передаваемые в него параметры\n" +
            "12. Какие методы называются перегруженными?\n" +
            "    Методы с одинаковыми названиями, но разными параметрами. Расположены в одном классе или\n" +
            "    в классах связанных наследованием.\n" +
            "13. Могут ли нестатические методы перегрузить статические?\n" +
            "    Да\n" +
            "14. Расскажите про переопределение методов.\n" +
            "    Это когда метод в классе наследнике совпадает с сигнатурой метода родительского класса\n" +
            "15. Может ли метод принимать разное количество параметров (аргументы переменной длины)?\n" +
            "    Да\n" +
            "16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?\n" +
            "    Нельзя\n" +
            "17. Как получить доступ к переопределенным методам родительского класса?\n" +
            "    Через ключевое слово super\n" +
            "18. Какие преобразования называются нисходящими и восходящими?\n" +
            "    Для примитивных типов данных:\n" +
            "        нисходящее - приведение к совместимому типу, занимающему меньше памяти\n" +
            "        восходящее - приведение к совместимому типу, занимающему больше памяти\n" +
            "    Для объектов:\n" +
            "        нисходящее - для объектов, связанных наследованием, приведение к более низкому уровню иерархии\n" +
            "        восходящее - для объектов, связанных наследованием, приведение к более высокому уровню иерархии\n" +
            "19. Чем отличается переопределение от перегрузки?\n" +
            "    Перегрузка: методы с одинаковым именем отличающиеся принимаемыми параметрами. Могут находиться внутри\n" +
            "    класса или классах связанных наследованием.\n" +
            "    Переопределение: методы с одинаковой сигнатурой. Не могут быть в одном классе, только в связанных\n" +
            "    наследованием.\n" +
            "20. Где можно инициализировать статические/нестатические поля?\n" +
            "    В месте объявления, конструкторе класса, блоке инициализации\n" +
            "21. Зачем нужен оператор instanceof?\n" +
            "    Для проверки экземпляром какого класса является объект\n" +
            "22. Зачем нужны и какие бывают блоки инициализации?\n" +
            "    Блоки бывают статическими и не статическими. Позволяют включать дополнительные выражения, подобно\n" +
            "    методам. Используются, когда нужно делать доп проверки, или вычисления, при инициализации поляЮ или\n" +
            "    вместо конструкторов, при инициализации полей анонимных классов.\n" +
            "23. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?\n" +
            "    Статические блоки предка\n" +
            "    Статические блоки потомка\n" +
            "    Не статический блок предка\n" +
            "    Конструктор предка\n" +
            "    Не статический блок потомка\n" +
            "    Конструктор потомка\n" +
            "24. Где и для чего используется модификатор abstract?\n" +
            "    Модификатор используемый с классами и методами. Декларирует шаблон для создания класса с методами,\n" +
            "    без их реализации. Конкретная реализация делается в классе наследнике.\n" +
            "25. Можно ли объявить метод абстрактным и статическим одновременно?\n" +
            "    Нет\n" +
            "26. Что означает ключевое слово static?\n" +
            "    К static методу или полю можно обратиться напрямую по имени, без создания экземпляра класса\n" +
            "27. К каким конструкциям Java применим модификатор static?\n" +
            "    Переменным\n" +
            "    Методам\n" +
            "    Блокам инициализации\n" +
            "28. Можно ли перегрузить static метод?\n" +
            "    Да\n" +
            "29. Что такое статический класс, какие особенности его использования?\n" +
            "    Может быть только вложенным классом. Static класс имеет доступ к статическим полям и методам\n" +
            "    основного класса. Его объект может быть создан без создания объекта основного класса.\n" +
            "    Используется для группировки и более удобного вызова логически связанных классов.\n" +
            "30. Какие особенности инициализации final static переменных?\n" +
            "    Должны быть инициализированы при объявлении\n" +
            "31. Как влияет модификатор static на класс/метод/поле?\n" +
            "    Обращение к методу и полю может быть по имени, без создания объекта класса. Статик метод в родительском\n" +
            "    классе не может быть переопределен наследником. Имеют приоритетную инициализацию при компиляции\n" +
            "    программы. Особенности для класса в вопросе 29.\n" +
            "32. О чем говорит ключевое слово final?\n" +
            "    Класс:      запрет наследования\n" +
            "    Метод:      запрет переопределения\n" +
            "    Переменная: запрет изменения значения после присвоения\n" +
            "33. Дайте определение понятию “интерфейс”.\n" +
            "    Это абстрактный класс, группирующий связаные по смыслу методы - без их реализации и поля константы.\n" +
            "34. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?\n" +
            "    Поля: public static final\n" +
            "    Методы: public abstract\n" +
            "35. Почему нельзя объявить метод интерфейса с модификатором final или static?\n" +
            "    Нет - по умолчанию методы абстрактные\n" +
            "36. Какие типы классов бывают в java (вложенные… и.т.д.)\n" +
            "    Класс\n" +
            "    Абстрактный класс\n" +
            "    Внутренние классы:\n" +
            "        Вложенный класс (статический/не статический)\n" +
            "        Анонимный класс\n" +
            "        Внутри метода\n" +
            "37. Какие особенности создания вложенных классов: простых и статических.\n" +
            "    Не статические вложенные классы не имеют доступ полям/методам основного класса, даже private.\n" +
            "    Статические вложенные классы не имеют доступ к нестатическим полям/методам основного класса\n" +
            "38. Какие классы называются анонимными?\n" +
            "    Это класс без имени создаваемый внутри метода\n" +
            "39. Как связан любой пользовательский класс с классом Object?\n" +
            "    Любые создаваемые классы являются наследниками Object\n" +
            "40. Расскажите про каждый из методов класса Object.\n" +
            "    clone() - копирует объект\n" +
            "    equals(Object obj) - сравнивает объекты\n" +
            "    finalize() - вызывается перед удалением неиспользуемого объекта\n" +
            "    getClass() - получает класс объекта во время выполнения\n" +
            "    hashCode() - возвращает хеш-код, связанный с объектом\n" +
            "    toString() - возвращает строку, описывающий объект\n" +
            "41. Чем отличается абстрактный класс от интерфейса, в каких случаях что вы будете использовать?\n" +
            "    Абстрактный интерфейс может содержать только static final поля, не имеет конструкторов,\n" +
            "    может содержать только методы без тела. Модификатор доступа к полям и методам Public по\n" +
            "    умолчанию и не может быть изменен. Может только расширить другой интерфейс.\n" +
            "    В абстрактном классе могут быть не статические и не финальные поля, конструкторы, реализованые методы,\n" +
            "    члены класса могут иметь разные модификаторы доступа. Может наследоваться от класса и реализовывать\n" +
            "    интерфейс.\n" +
            "    Интерфейс обязывает соблюдать определенную реализацию, даже для не связанных классов.\n" +
            "    От абстрактного класса можно только наследоваться.\n" +
            "42. Можно ли получить доступ к private переменным класса и если да, то каким образом?\n" +
            "    Да, изнутри класса. Извне, только через не private методы внутри класса\n" +
            "43. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость?\n" +
            "    А если protected? А сузить видимость?\n" +
            "    Private метод не виден потомку.\n" +
            "    Protected - видимость можно расширить.\n" +
            "    Сужать видимость нельзя.\n" +
            "44. Имеет ли смысл объявлять метод private final?\n" +
            "    Нет, т.к. он не виден в классе наследнике и не может быть переопределен.\n" +
            "45. Какие особенности инициализации final переменных?\n" +
            "    Может быть объявлено при инициализации, в конструкторе, в блоке.\n" +
            "46. Что будет, если единственный конструктор класса объявлен как final?\n" +
            "    Final применить нельзя";
}